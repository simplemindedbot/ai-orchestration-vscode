# API Reference

This document provides comprehensive API documentation for the AI Orchestration system.

## Core Interfaces

### DiscoveredTool

Represents an AI tool discovered by the system.

```typescript
interface DiscoveredTool {
  /** Unique identifier for the tool */
  id: string;

  /** Human-readable display name */
  name: string;

  /** Integration method used to connect to this tool */
  type: 'mcp-server' | 'vscode-extension' | 'cli-tool' | 'api-service';

  /** What this tool can do */
  capabilities: ToolCapabilities;

  /** Connection handler for this tool */
  connector: ToolConnector;

  /** Network endpoint (for MCP/API tools) */
  endpoint?: string;

  /** Current health status */
  isHealthy: boolean;

  /** Last time health was checked */
  lastChecked: Date;
}
```

### ToolCapabilities

Defines what a tool can do and its constraints.

```typescript
interface ToolCapabilities {
  /** Task types this tool can handle */
  tasks: TaskType[];

  /** Programming languages supported */
  languages: string[];

  /** External integrations available */
  integrations: string[];

  /** VS Code commands exposed (for extensions) */
  commands: string[];

  /** Maximum context size in tokens */
  contextSize?: number;

  /** Rate limiting information */
  rateLimit?: RateLimit;
}

type TaskType =
  | 'planning'
  | 'completion'
  | 'analysis'
  | 'deployment'
  | 'testing'
  | 'refactoring'
  | 'documentation'
  | 'debugging'
  | 'security'
  | 'general-purpose';
```

### Task

Represents a work item to be executed by AI tools.

```typescript
interface Task {
  /** Type of task being performed */
  type: TaskType;

  /** Human-readable description of what to do */
  description: string;

  /** Code and workspace context */
  context: WorkspaceContext;

  /** Task priority level */
  priority: 'high' | 'medium' | 'low';

  /** Programming language (if relevant) */
  language?: string;

  /** Task complexity estimate */
  complexity?: 'simple' | 'medium' | 'complex';

  /** Additional metadata */
  metadata?: Record<string, any>;
}
```

### WorkspaceContext

Provides context about the current development environment.

```typescript
interface WorkspaceContext {
  /** Currently open files and their content */
  openFiles: FileContext[];

  /** Current cursor position and selection */
  selection?: TextSelection;

  /** Project root directory */
  workspaceRoot: string;

  /** Detected project type and technologies */
  projectInfo: ProjectInfo;

  /** Git repository information */
  gitInfo?: GitContext;

  /** Environment variables and configuration */
  environment: Record<string, string>;
}
```

## Core Classes

### ToolDiscovery

Handles automatic discovery and cataloging of available AI tools.

```typescript
class ToolDiscovery {
  /** Initialize discovery process */
  async initializeDiscovery(): Promise<void>;

  /** Re-run discovery to find new or changed tools */
  async rediscoverTools(): Promise<void>;

  /** Get all currently discovered tools */
  getDiscoveredTools(): Map<string, DiscoveredTool>;

  /** Get tools that can handle a specific task type */
  getToolsForTask(taskType: TaskType): DiscoveredTool[];

  /** Manually register a custom tool */
  async registerCustomTool(config: ToolConfig, connector: ToolConnector): Promise<void>;

  /** Remove a tool from the registry */
  unregisterTool(toolId: string): void;

  /** Test health of all discovered tools */
  async performHealthChecks(): Promise<HealthCheckResults>;
}
```

### AdaptiveTaskRouter

Intelligently routes tasks to the most appropriate available tools.

```typescript
class AdaptiveTaskRouter {
  constructor(
    availableTools: Map<string, DiscoveredTool>,
    userPreferences: OrchestrationConfig
  );

  /** Generate routing plan for a task */
  async routeTask(task: Task): Promise<RoutingPlan>;

  /** Update available tools (called when discovery changes) */
  updateAvailableTools(tools: Map<string, DiscoveredTool>): void;

  /** Recompute routing strategies (called when tools fail) */
  async recomputeRoutingStrategies(): Promise<void>;

  /** Get routing explanation for a task */
  explainRouting(task: Task): Promise<RoutingExplanation>;
}
```

### RoutingPlan

Execution plan generated by the router.

```typescript
interface RoutingPlan {
  /** Primary tool to handle the task */
  primary: DiscoveredTool;

  /** Supporting tools for collaboration */
  supporting: DiscoveredTool[];

  /** Fallback tools if primary fails */
  fallbacks: DiscoveredTool[];

  /** Whether this is a degraded mode operation */
  degraded?: boolean;

  /** Human-readable explanation of routing decision */
  explanation: string;

  /** Confidence score (0-1) in this routing plan */
  confidence: number;
}
```

### AIOrchestrator

Main orchestration controller that coordinates multi-agent task execution.

```typescript
class AIOrchestrator {
  /** Execute a task using optimal tool coordination */
  async orchestrateTask(request: string): Promise<OrchestrationResult>;

  /** Execute a specific task object */
  async executeTask(task: Task): Promise<TaskResult>;

  /** Execute multiple tasks in parallel */
  async executeParallel(tasks: Task[]): Promise<TaskResult[]>;

  /** Get status of active orchestrations */
  getActiveOrchestrations(): CollaborationSession[];

  /** Cancel a running orchestration */
  async cancelOrchestration(sessionId: string): Promise<void>;
}
```

### ToolConnector

Abstract base class for tool integration implementations.

```typescript
abstract class ToolConnector {
  /** Establish connection to the tool */
  abstract connect(): Promise<Connection>;

  /** Execute a task using this tool */
  abstract invoke(task: Task, context: WorkspaceContext): Promise<ToolResponse>;

  /** Test if the tool is currently healthy/available */
  abstract testHealth(): Promise<boolean>;

  /** Clean up and disconnect from the tool */
  abstract disconnect(): Promise<void>;

  /** Get tool-specific configuration options */
  getConfigurationSchema(): ConfigurationSchema;

  /** Handle tool-specific errors */
  protected handleError(error: Error): ToolError;
}
```

## Specific Connectors

### MCPConnector

Connector for Model Context Protocol servers.

```typescript
class MCPConnector extends ToolConnector {
  constructor(endpoint: string, options?: MCPOptions);

  async connect(): Promise<MCPConnection>;

  async invoke(task: Task, context: WorkspaceContext): Promise<ToolResponse>;

  /** Send raw MCP request */
  async sendMCPRequest(method: string, params: any): Promise<any>;

  /** List available MCP tools */
  async listMCPTools(): Promise<MCPTool[]>;

  /** Get MCP server capabilities */
  async getServerCapabilities(): Promise<MCPCapabilities>;
}
```

### VSCodeExtensionConnector

Connector for VS Code extension APIs.

```typescript
class VSCodeExtensionConnector extends ToolConnector {
  constructor(extension: vscode.Extension<any>);

  async invoke(task: Task, context: WorkspaceContext): Promise<ToolResponse>;

  /** Execute VS Code command */
  async executeCommand(command: string, ...args: any[]): Promise<any>;

  /** Check if extension supports specific capability */
  supportsCapability(capability: string): boolean;

  /** Get extension configuration */
  getExtensionConfig(): vscode.WorkspaceConfiguration;
}
```

### CLIConnector

Connector for command-line AI tools.

```typescript
class CLIConnector extends ToolConnector {
  constructor(command: string, options?: CLIOptions);

  async invoke(task: Task, context: WorkspaceContext): Promise<ToolResponse>;

  /** Execute CLI command with arguments */
  async executeCommand(args: string[]): Promise<CLIResult>;

  /** Check if CLI tool is available in PATH */
  static async isAvailable(command: string): Promise<boolean>;

  /** Get CLI tool version */
  async getVersion(): Promise<string>;
}
```

## Configuration Interfaces

### OrchestrationConfig

Main configuration object for the orchestration system.

```typescript
interface OrchestrationConfig {
  discovery: DiscoveryConfig;
  routing: RoutingConfig;
  capabilities: CapabilitiesConfig;
  user: UserConfig;
}

interface DiscoveryConfig {
  /** Enable automatic tool discovery */
  enableAutoDiscovery: boolean;

  /** Ports to scan for MCP servers */
  scanPorts: number[];

  /** Allowed extension IDs */
  extensionWhitelist: string[];

  /** Paths to MCP configuration files */
  mcpConfigPaths: string[];

  /** How often to rediscover tools (ms) */
  discoveryInterval: number;
}

interface RoutingConfig {
  /** User preferences for task routing */
  preferredTools: Record<TaskType, string[]>;

  /** How to handle fallbacks */
  fallbackBehavior: 'graceful' | 'fail-fast';

  /** Parallelism strategy */
  parallelismLevel: 'conservative' | 'aggressive';

  /** Maximum concurrent tasks */
  maxConcurrentTasks: number;
}
```

## Events and Callbacks

### Discovery Events

```typescript
interface DiscoveryEvents {
  /** Fired when new tools are discovered */
  onToolsDiscovered: (tools: DiscoveredTool[]) => void;

  /** Fired when a tool becomes unhealthy */
  onToolUnhealthy: (tool: DiscoveredTool, error: Error) => void;

  /** Fired when a tool recovers */
  onToolRecovered: (tool: DiscoveredTool) => void;

  /** Fired when discovery process completes */
  onDiscoveryComplete: (summary: DiscoverySummary) => void;
}
```

### Orchestration Events

```typescript
interface OrchestrationEvents {
  /** Fired when task routing begins */
  onRoutingStart: (task: Task) => void;

  /** Fired when routing plan is generated */
  onRoutingComplete: (plan: RoutingPlan) => void;

  /** Fired when task execution begins */
  onExecutionStart: (session: CollaborationSession) => void;

  /** Fired when tool responds */
  onToolResponse: (toolId: string, response: ToolResponse) => void;

  /** Fired when conflict resolution is needed */
  onConflictDetected: (conflict: Conflict) => void;

  /** Fired when orchestration completes */
  onOrchestrationComplete: (result: OrchestrationResult) => void;
}
```

## Error Handling

### Error Types

```typescript
class ToolError extends Error {
  constructor(
    message: string,
    public toolId: string,
    public originalError?: Error
  );
}

class DiscoveryError extends Error {
  constructor(
    message: string,
    public discoveryTarget: string,
    public originalError?: Error
  );
}

class RoutingError extends Error {
  constructor(
    message: string,
    public task: Task,
    public availableTools: string[]
  );
}

class OrchestrationError extends Error {
  constructor(
    message: string,
    public sessionId: string,
    public partialResults?: TaskResult[]
  );
}
```

## Utility Functions

### Tool Registration

```typescript
/** Register a custom tool with the system */
async function registerTool(
  config: ToolConfig,
  connector: ToolConnector
): Promise<void>;

/** Unregister a tool */
function unregisterTool(toolId: string): void;

/** Get all registered tools */
function getRegisteredTools(): DiscoveredTool[];
```

### Configuration Management

```typescript
/** Load configuration from VS Code settings */
function loadConfig(): OrchestrationConfig;

/** Save configuration to VS Code settings */
async function saveConfig(config: OrchestrationConfig): Promise<void>;

/** Get default configuration */
function getDefaultConfig(): OrchestrationConfig;

/** Validate configuration object */
function validateConfig(config: OrchestrationConfig): ValidationResult;
```

### Health Monitoring

```typescript
/** Check health of all tools */
async function checkAllToolsHealth(): Promise<HealthStatus>;

/** Check health of specific tool */
async function checkToolHealth(toolId: string): Promise<boolean>;

/** Get health history for a tool */
function getHealthHistory(toolId: string): HealthCheckResult[];
```

## Extension Points

### Custom Tool Integration

```typescript
/** Interface for custom tool implementations */
interface CustomToolConnector extends ToolConnector {
  /** Tool-specific configuration schema */
  getConfigSchema(): JSONSchema;

  /** Custom capability testing */
  testCapabilities(): Promise<ToolCapabilities>;

  /** Tool-specific error handling */
  handleToolError(error: Error): ToolError;
}
```

### Workflow Templates

```typescript
interface WorkflowTemplate {
  /** Template identifier */
  id: string;

  /** Human-readable name */
  name: string;

  /** Template description */
  description: string;

  /** Sequence of tasks to execute */
  taskSequence: TaskTemplate[];

  /** Tool preferences for this workflow */
  toolPreferences: ToolPreference[];

  /** Conditional routing logic */
  conditionalLogic: RoutingCondition[];
}

interface TaskTemplate {
  /** Task type */
  type: TaskType;

  /** Task description template */
  descriptionTemplate: string;

  /** Required tool capabilities */
  requiredCapabilities: string[];

  /** Whether this task can run in parallel */
  parallelizable: boolean;
}
```

This API reference provides the foundation for building custom integrations, workflow automation, and advanced orchestration features.